\begin{figure}

\begin{subfigure}[b]{0.7\textwidth}
\begin{ocaml}
module type MList = sig
  module A: MERGEABLE
  include MERGEABLE
  type t = A.t list [@@deriving versioned]
  type edit = I of A.t * int
    | D of int
    | S of int * A.t * A.t
    | Nop
  ... (* All the standard list functions *)
  val insert: A.t -> int -> t -> t
  val delete: int -> t -> t
  val subst: int -> A.t -> t
  val edit_seq: t -> t -> edit list option
  val op_transform: edit list -> edit list -> edit list
  val merge: t -> t -> t -> t
end
\end{ocaml}
\caption{Signature of Mergeable Lists}
\label{fig:mlist-sig}
\end{subfigure}

\begin{subfigure}{0.75\textwidth}
\begin{ocaml}
(*
 * We reduce the problem of transforming op1* w.r.t op2* 
 * first to the problem of transforming op1* w.r.t op2,
 * and then to the problem of transforming op1 w.r.t op2.
*)
let op_transform mine others = 
  (*
   * Transforms my edit w.r.t other edit, and also returns how 
   * edits following my edit will witness the other edit.
   *)
  let xform my other = 
    let f my' = (my',other) in
    let g other' = (my,other') in
      match (my,other)  with 
      | (I (x,j), I (_,i)) when (j>=i) -> f @@ I (x,j+1)
      | (D j, I (_,i)) when (j>=i) -> f @@ D (j+1)
      | (S (j,x,y), I (_,i)) when (j>=i) -> f @@ S (j+1,x,y)
      | (I (x,j), D i) when (j=i) ->  g @@ Nop
      | (I (x,j), D i) when (j>i) ->  f @@ I (x,j-1)
      | (D j, D i) when (j=i) -> (Nop, Nop)
      | (D j, D i) when (j>i) ->  f @@ D (j-1)
      | (S (j,x,y), D i) when (j=i) -> f @@ Nop
      | (S (j,x,y), D i) when (j>i) -> f @@ S (j-1,x,y)
      | (I (x,j), S (i,y,z)) when (j<=i) -> g @@ S (i+1,y,z)
      | (D j, S (i,y,z)) when (j=i) -> g @@ Nop
      | (D j, S (i,y,z)) when (j<i) -> g @@ S (i-1,y,z)
      | (S (j,x,y), S (i,_,z)) when (j=i) -> f @@ S (j,x,A.merge x y z) 
      | _ -> f @@ my in
  let mine' = 
    List.fold_left 
      (fun mine other -> 
         let (mine',_) = 
           List.fold_left 
             (fun (xformed, other) my -> 
                let (my',other') = xform my other in
                  (xformed@[my'],other')) 
             ([],other) mine in
           mine') 
      mine others in
    mine'
\end{ocaml}
\caption{Operational transformation of list operations}
\label{fig:mlist-xform}
\end{subfigure}

\caption{Mergeable List Implementation}
\label{fig:mlist}
\end{figure}
