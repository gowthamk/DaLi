\section{Operational Semantics}

\input{opsem}

We formalize our ideas in the context of a lambda calculus ($\lang$)
shown in Fig.~\ref{fig:opsem}. Expressions of $\lang$ are variables,
constants, and \name primitives composed using the lambda combinator.
For brevity, we use short names for \name primitives: \C{run} for
\C{with\_init\_version\_do}, and \C{fork} for \C{fork\_version}. To
simplify the technical development, \name's \C{sync\_next\_version}
operation is broken down into two primitives - \C{push} and \C{pull},
which can be lambda-composed get the desired effect:
\begin{smathpar}
  \C{sync}\;x \;=\; (\lambda y.\pull)\; (\push\,x)
\end{smathpar}
The semantics of\C{get\_current\_version} is subsumed by \C{pull},
hence elided.  Values ($v$) are constants and lambda abstractions.  A
program ($p$) is a parallel composition of threads, where each thread
is an expression ($s$) indexed by the corresponding thread identifier
($t$). 

Fig.~\ref{fig:opsem} also shows the syntax of \emph{branches}, which
are the artifacts of evaluation and only appear during the run-time. A
branch is a non-empty sequence of tagged values, where the tag
captures the abstract run-time operation that led to the creation of
the value. It is implicitly assumed that each value added to a branch
is uniquely identifiably, hence no two values on a branch are equal.
The uniqueness assumption is later extended to a collection of
branches that constitute a branching structure. A real implementation
meets this assumption by versioning values across the branches. Thus,
in reality, branches contain \emph{versions} which denote values. The
semantics, however, doesn't make this distinction, and uses values and
versions interchangeably.

Small-step operational semantics of $\lang$ is defined via reduction
relation ($\stepsto$) that relates \emph{program states}. A program
state ($p;\,H$) consists of a program $p$ and a \emph{branch history}
$H$ that maps thread Ids to corresponding branches; each thread is
associated with a branch during the evaluation. Evaluation contexts
have been defined separately for expressions ($E$) and programs ($P$),
with the latter subsuming the former. $E$ is defined to evaluate the
first argument of a \C{run} expression to a value that constitutes the
initial version (recall that \C{run} models \name's
\C{with\_init\_version\_do}). Program evaluation context
non-deterministically picks one of the threads to evaluate. The admin
rule that relates transitions of holes to transitions of expressions
and programs is straightforward, hence elided. Rest of the reduction
rules are presented in Fig.~\ref{fig:opsem}. For brevity, we write
$H(t\mapsto (v,f))$ to denote the proposition that $H$ maps $t$ to
$(v,f)$. The notation $H[t \mapsto (v,f)]$ as usual denotes
the extension of $H$ with the binding $t \mapsto (v,f)$.

Reduction rules let expression evaluation take a step by rewriting the
expression and suitably updating the branch history ($H$). The
\rulelabel{E-Run} rule is applicable only when $H$ is empty, i.e.,
when no prior branching structure exists. The rule rewrites the
$\C{run}\;v\;s$ expression to $s$, while creating a new branching
structure with two branches: a \emph{top} branch that has just the
initial version (tagged with \C{INIT}), and a branch for the current
thread ($t$) forked-off from the top branch.  The first version on the
current branch ($H(t)$) denotes the same value ($v$) as the initial
version on the top branch, although versions themselves are deemed
distinct. The new version is tagged with a \C{FORK} tag that keeps the
record of its orgin, namely the \C{fork} operation and the branch from
which the current branch is forked. The \rulelabel{E-Fork} rule forks
a new thread with a fresh id ($t'$) and adds it to the thread pool.
The corresponding branch ($H(t')$) is forked from the parent thread's
branch ($H(t)$). The semantics of branch forking is same as described
above. The \C{fork} expression in the parent thread evaluates to
\C{()}. The \rulelabel{E-Push} rule creates a new version on the
current branch ($H(t)$) using the pushed value ($v$).
\rulelabel{E-App} is the standard beta reduction rule.

The semantics non-deterministically chooses \rulelabel{E-Pull} or
\rulelabel{E-Pull-Wait} rules to reduce a \C{pull} expression. The
\rulelabel{E-Pull} rule reduces \C{pull} to \C{()}, and returns the
latest version on the current branch. The \rulelabel{E-Pull-Wait} rule
can be thought of as a stutter step; it doesn't reduce \C{pull}, but
updates the branching structure by merging (the latest version of) a
concurrent branch ($H(t')$) into (the latest version of) the current
branch ($H(t)$), and extending the current branch with the merged
version ($v_m$). The new version is tagged with a \C{MERGE} tag that,
like a \C{FORK} tag, records its origin. The premises of the
\rulelabel{E-Pull-Wait} serve the important purpose of contraining the
branching structure by allowing only the legal merges, and
consequently preserving certain desirable properties of the system;
we will go into the details shortly. The \rulelabel{E-Pull-Wait} and
\rulelabel{E-Pull} rules thus let a thread sync with a subset of
concurrent threads in multiple steps before returning the result of
the \C{pull}. Since \C{sync} is a composition of \C{push} and
\C{pull}, its behavior can be explained thus: \C{sync} pushes the
given value onto the current (local) branch, merges a (possibly empty)
subset of concurrent branches into the local branch, and returns the
result.

We will now present a series of definitions and results that let us
understand the premises of the \rulelabel{E-Pull-Wait} rule, examine
the merge operation in closer detail, and appreciate the need for
constraining the branching structure. First, we formalize the
intuitive notation of the ancestor relationship between versions of a
legal branching history (i.e., a branching history generated by the
rules in Fig.~\ref{fig:opsem}):

\begin{definition} [\bfseries Ancestor]
Version $v_1$ is a ancestor of version $v_2$ under a history
$H$ (written $\under{H}{v_1 \preceq v_2}$) if and only if one of the
following is true:
\begin{itemize}
  \item There exists a branch $b$ in $H$ (i.e., $\exists(t\in
  dom(H)).\,H(t) = b$) in which $v_2$ immediately succeeds
  $v_1$,
  \item There exists a branch $b$ in $H$ that contains $(v_2, 
  \C{FORK}\; (v_1,f_1)::b_1)$, for some $f_1$ and $b_1$,
  \item There exists a branch $b$ in $H$ that contains
  $(v_2, \C{MERGE}\;(v_1,f_1)::b_1)$, for some $f_1$ and $b_1$,
  \item $v_1 = v_2$, or $v_1$ is transitively a ancestor of
  $v_2$, i.e., $\exists v.~ \under{H}{v_1 \preceq v} \conj
  \under{H}{v \preceq v}$ 
\end{itemize}
\end{definition}

Ancestor relation is therefore a partial order (reflexive, transitive,
anti-symmetric) with a greatest lower bound (the initial version).
Thus, for any two versions in a legal history, there exist at least
one common ancestor. Ancestor relationships among the common ancestors
let us define the notion of a least common ancestor (LCA):

\begin{definition} [\bfseries Least Common Ancestor]
Version $v$ is said to be a common ancestor of versions $v_1$ and
$v_2$ under a history $H$ if and only if $\under{H}{v \preceq v_1}$
and $\under{H}{v \preceq v_2}$. It is said to be the least common
ancestor (LCA) of $v_1$ and $v_2$, iff there does not exist a $v'$
such that $\under{H}{v' \preceq v_1}$ and $\under{H}{v' \preceq v_2}$
and $\under{H}{v \preceq v'}$.
\end{definition}

\begin{figure}
\centering
\includegraphics[scale=0.6]{Figures/merge-needs-lca}

\caption{This example of a grow-only counter illustrate why \C{merge}
needs a least common ancestor, and not just a common ancestor. Both 0
and 2 are common ancestors of 4 and 7, while 2 is their least common
ancestor (since $0 \preceq 2$). The result (v) of merging 4 and 7 is
11 (incorrect) if 0 is used as the common ancestor for merge, and 9
(correct, because 2+2+3+2 = 9) if 2 is used. }
\label{fig:merge-needs-lca}
\end{figure}

\begin{figure}[!t]
\centering
\subcaptionbox[] {\small
  In this example, 1 and 3 have two LCAs (3 and 4) a result of
  previous merges. The dotted circle denotes a virtual ancestor
  obtained by merging the two LCAs.
  \label{fig:criss-cross-lcas}
} [0.47\columnwidth] {
  \includegraphics[scale=0.55]{Figures/2-LCAs}
}
\hfill
\subcaptionbox[] {\small
  In this example, 3 and 6 have two LCAs (2 and 1) despite there not
  being any previous merges between their respective branches.
  \label{fig:external-lcas}
} [0.47\columnwidth] {
  \includegraphics[scale=0.7]{Figures/2-external-LCAs}
}
\caption{Examples where merging versions have more than one LCA}
\label{fig:many-lcas}
\end{figure}

When merging two concurrent versions $v_1$ and $v_2$, the common
ancestor argument for \C{merge} must the LCA of $v_1$ and $v_2$,
without which \C{merge} may yeild unexpected results. This is
demonstrated for the grow-only counter in
Fig.~\ref{fig:merge-needs-lca}, where incorrect count is obtained if a
common ancestor that is not an LCA is used to merge 4 and 7. While in
this example there is a unique LCA for 4 and 7, in general this may
not be the case. With unrestrained branching and merging, there is no
bound on the number of LCAs a pair of versions can have.
For example, in
Fig.~\ref{fig:criss-cross-lcas}, the merge of 0 with 3 is preceded by
two ``criss-cross'' merges between their respective branches resulting
in there being two LCAs (5 and 4) for 0 and 3. Multiple LCAs can occur
even without criss-cross merges, as demonstrated by
Fig.~\ref{fig:external-lcas}. The problem with concurrent versions
with multiple LCAs is that they do not lend themselves to three-way
merging. This problem also arises in the context of source
control systems, and often solved via ad-hoc mechanisms.
GitHub~\cite{github}, for instance, recursively merges LCAs to compute
a virtual ancestor, which then serves as the LCA for merging the
concurrent versions. This method is demonstrated for the example in
Fig.~\ref{fig:criss-cross-lcas}, where LCAs 5 and 4 of 0 and 3 are
merged (with LCA of 10) to generate -1 as the virtual LCA to merge 5
and 4. A major downside with this method is that it makes no
guarantees of the relationship between the virtual ancestor and the
concurrent versions; the former may not even be a legal ancestor of
the latter as per the semantics of the data type. For instance, the
integer type in Fig.~\ref{fig:criss-cross-lcas} may in fact represent
a bank account, which disallows any activity on the account if balance
is ever known to be less than zero. Thus, from the perspective of a
bank account, it doesn't make sense how concurrent versions 3 and 0
emerged from -1, since the only transition allowed by the semantics
from -1 is to itself. Clearly, ad hoc mechanisms, which work for the
text, may not work for more sophisticated data types.

Fortunately, unlike the source control systems where branching
structure is entirely dictated by the user, \name abstracts away the
branching structure from the programmer, hence retains the ability to
constrain it in a way that it deems fit. In particular, \name solves
the problem of multiple LCAs by suitably constraining the branching
structure such that the problem never arises. The constraints are
imposed either implicitly, as a result of how operational semantics
defines an atomic step, or explicitly, by insisting that certain
conditions be met before merging a pair of versions
(\rulelabel{E-Pull-Wait}). Firstly, the operational semantics already
disables criss-cross merges since it only ever merges versions that
are latest on their respective branches. For instance let $v_{11}$ and
$v_{21}$ be the latest versions on branches $b_1$ and $b_2$,
respectively. Meging $b_2$ into $b_1$ requires entails $v_{21}$ into
$v_{11}$ to generate version $v_{12}$ on $b_1$. Now, merging $b_1$
into $b_2$ translates to merging $v_{12}$ into $v_{21}$ (a
\emph{fast-forward} merge, in Git parlance), but not $v_{11}$ into
$v_{21}$, thus preventing a criss-cross branching structure. In other
words, a criss-cross branching structure is prevented due to the
order among merges between conflicting branches introduced as a result
of \rulelabel{E-Pull-Wait} being an atomic step. 

Secondly, we impose certain pre-conditions on the merging branches to
preempt the structure shown in Fig.~\ref{fig:external-lcas}. The
intuition is as follows: consider the branch $b_1$ at the instance of
merging $b_3$. Since it has already merged $b_2$, a version on $b_2$
($v_{22}$) could be a common ancestor for a version on $b_1$
($v_{12}$) and some other version (call it $v$). Now, if $b_1$ merges
$b_3$, same could be true of $b_3$ and $b_1$: a version on $b_3$
($v_{32}$) could be a common ancestor for the new version on $b_1$
($v_{13}$), and the other version $v$. Since $v_{22}$ is also an
ancestor of $v_{13}$, and both ancestors are not ordered by the
ancestor relation, $v_{13}$ and $v$ end up with two LCAs. In
Fig.~\ref{fig:external-lcas}, the role of $v$ is played by the version
$v_{44}$. We observe that this scenario can be prevented if, when
merging $b_3$, $b_1$ insists on an ancestor relation between the
merged version ($v_{22}$) of the $b_2$, the previously merged branch,
and the latest version of $b_3$, the current merging branch. We call
the last merged version the \emph{external locus} of the branch. By
requiring that, for every branch $b$, the external locii of $b$ at
various points in time (i.e., external locus of every prefix of $b$)
be totally ordered, we effectively enforce the invariant that for any
two common ancestors $v_1$ and $v_2$ between two versions, there
exists another common ancestor $v_3$ that succeeds $v_1$ and $v_3$ in
the ancestor relation, thereby preventing the possibility of multiple
LCAs.

%% <false>
%% Multiple versions that merge any pair of versions are totally
%% ordered. That is, if $v_1$ and $v_2$ are ancestors of $v_3$ and
%% $v_4$, then $v_3$ and $v_4$ are ordered by the ancestor relation.
%% </false>

%% If $v_1$ and $v_2$ are ancestors of $v_3$ and $v_4$, then there
%% exists a $v_5$, a successor of $v_1$ and $v_2$, and an ancestor of
%% $v_3$ and $v_4$
%% If I follow one of your locii, or you follow one of my locii, then
%% we both have same set of external common ancestors.

Let us see how the aforementioned restriction allows us to merge the
branches in Fig.~\ref{fig:external-lcas} without ever creating
multiple LCAs. The legal branching history is shown in
Fig.~\ref{fig:legal-merge}. First, like in
Fig.~\ref{fig:external-lcas}, $b_2$ is merged into $b_1$ to create
$v_{12}$, and $b_3$ is merged into $b_4$ to create $v_{42}$. Thus, the
external locus of $b_1$ is $v_{22}$, and that of $b_4$ is $v_{32}$.
Observe that now $b_1$ cannot merge $b_3$, neither can $b_4$ merge
$b_2$ because $v_{22}$ and $v_{32}$ are not related by the ancestor
relation. Same applies for $b_1$ and $b_4$ because neither one's
latest version follows from other's external locus.  However, $b_2$
and $b_3$ can merge among themselves. Let us say they indeed merge to
to create a version $v_{23}$ on $b_2$. The branch $b_2$ is now
eligible to be merged into $b_1$ and also $b_4$. These merges do occur
in Fig.~\ref{fig:legal-merge} to create versions $v_{13}$ and
$v_{43}$, and making $v_{23}$ the external locus for both $b_1$ and
$b_4$. Thus, $b_1$ can now merge into $b_4$ to create version $v_{44}$
on $b_4$.

We now formalize the intuitions described above to precisely define
the notion of mergeability:

\begin{definition} [\bfseries Internal and External Ancestors]
Given a branch $b$ and a version $v\in b$, an internal ancestor of $v$
is an ancestor from the same branch $b$. An external ancestor of $v$
is an ancestor from a different branch $b'\neq b$. 
\end{definition}

\begin{definition} [\bfseries External Locus]
Given a branch $b$ and a version $v\in b$, external locus ($v_o$) of
$v$ is an external ancestor that is not an ancestor of any other
external ancestor of $v$. That is, $\under{H}{v_o \preceq v}$, and
there does not exist a $v_o' \not\in b$ such that $\under{H}{v_o'
\preceq v}$ and $\under{H}{v_o \preceq v_o'}$. 
\end{definition}

\begin{definition} [\bfseries Mergeability]
Given a history $H$, a version $v_1$ and a version $v_2$ that is not
an ancestor of $v_1$ under $H$, $v_2$ is mergeable into $v_1$ (denoted
$\under{H}{v_2 \mbleto v_1}$) iff $v_1$'s external locus is an
ancestor of $v_2$, or $v_2$'s external locus is an ancestor of $v_1$.
\end{definition}

Rule \rulelabel{E-Pull-Wait} of the reduction relation
(Fig.~\ref{fig:opsem}) is enabled only if the latest version ($v'$)
of thread $t'$'s branch is mergeable into the latest version ($v$) of
thread $t$'s branch (i.e., $\under{H}{v' \mbleto v}$). Merge computes
the latest common ancestor of $v$ and $v'$, which is 
guaranteed to be unique as per the following theorem\footnote{Proof
included in the appendix}:

\begin{theorem} [\bfseries Unique LCA]
Every pair of versions $v_1$ and $v_2$ in a legal branch history $H$ 
have a unique least common ancestor. 
\end{theorem}

The \rulelabel{E-Pull-Wait} uses the function \C{lca} to compute the
LCA of (the latest versions on) a pair of branches. The definition of
the function is standard, hence not discussed.
